#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/sequent/generator'

command = ARGV[0].to_s.strip
args = (ARGV[1..-1] || []).map(&:to_s).map(&:strip)

if command.empty?
  abort <<~EOS
    Usage: #{$PROGRAM_NAME} command arguments...

    Please specify a command, for example `sequent new myapp`. Available commands:

      new appname                 Generate a new project from the Sequent template
                                  project
      generate type arguments...  Generate a new aggregate, command, or event

      migrate                     Migrate a Sequent 7.1 database to Sequent 8
  EOS
end

def new_project(name = nil, *args)
  abort('Please specify a directory name. i.e. `sequent new myapp`') if name.empty?
  abort("Unknown arguments '#{args.join(' ')}', aborting") unless args.empty?

  Sequent::Generator::Project.new(name).execute
  puts <<~NEXTSTEPS

    Success!

    Your brand spanking new sequent app is waiting for you in:
      #{File.expand_path(name, Dir.pwd)}

    To finish setting up your app:
      cd #{name}
      bundle install
      bundle exec rake sequent:db:create
      bundle exec rake sequent:db:create_view_schema
      bundle exec rake sequent:migrate:online
      bundle exec rake sequent:migrate:offline

    Run the example specs:
      SEQUENT_ENV=test bundle exec rake sequent:db:create
      bundle exec rspec spec

    To generate new aggregates use:
      sequent generate <aggregate_name>. e.g. sequent generate address

    For more information see:
      https://www.sequent.io

    Happy coding!

  NEXTSTEPS
rescue TargetAlreadyExists
  abort("Target '#{name}' already exists, aborting")
end

def generate_aggregate(aggregate_name = nil, *args)
  abort('Please specify an aggregate name. i.e. `sequent g aggregate user`') unless args_valid?(aggregate_name)
  abort("Unknown arguments '#{args.join(' ')}', aborting") unless args.empty?

  Sequent::Generator::Aggregate.new(aggregate_name).execute
  puts "#{aggregate_name} aggregate has been generated"
rescue TargetAlreadyExists
  abort("Target '#{aggregate_name}' already exists, aborting")
end

def generate_command(aggregate_name = nil, command_name = nil, *attrs)
  unless args_valid?(aggregate_name, command_name)
    abort('Please specify an aggregate name and command name. i.e. `sequent g command User AddUser`')
  end
  Sequent::Generator::Command.new(aggregate_name, command_name, attrs).execute
  puts "#{command_name} command has been added to #{aggregate_name}"
rescue NoAggregateFound
  abort("Aggregate '#{aggregate_name}' not found, aborting")
end

def generate_event(aggregate_name = nil, event_name = nil, *attrs)
  abort('Please specify an aggregate name and event name. i.e. `sequent g event User UserAdded`') unless args_valid?(
    aggregate_name, event_name
  )
  Sequent::Generator::Event.new(aggregate_name, event_name, attrs).execute
  puts "#{event_name} event has been added to #{aggregate_name}"
rescue NoAggregateFound
  abort("Aggregate '#{aggregate_name}' not found, aborting")
end

def generate(entity = nil, *args)
  case entity
  when 'aggregate'
    generate_aggregate(*args)
  when 'command'
    generate_command(*args)
  when 'event'
    generate_event(*args)
  else
    abort <<~EOS
      Unknown type for `generate`. Try `sequent g aggregate User`. Available options:

        generate aggregate Name
              Generates the aggregate `Name`

        generate command Aggregate Command attributes...
              Generates the command `Command` for aggregate `Aggregate`

        generate event Aggregate Event attributes...
              Generates the event `Event` for aggregate `Aggregate`
    EOS
  end
end

def confirm_or_abort
  loop do
    puts 'Enter `yes` to continue, `abort` to abort'

    line = $stdin.readline
    puts

    abort('Aborted by user') if line.strip == 'abort'

    break if %w[y yes].include? line.strip.downcase
  end
rescue EOFError
  abort('Aborted by user')
end

def migrate(*args)
  abort("Unknown arguments '#{args.join(' ')}', aborting") unless args.empty?

  copy_schema, sequent_gem_dir =
    begin
      [true, Gem::Specification.find_by_name('sequent').gem_dir]
    rescue Gem::MissingSpecError
      [false, File.expand_path('..', __dir__)]
    end

  puts <<~EOS
    This script will guide you through upgrading your Sequent application to Sequent 8.

    The Sequent 8 database has been further optimized for disk usage and
    performance. In addition it supports partitioning the tables for aggregates,
    commands, and events, making it easier to manage the database (VACUUM,
    CLUSTER) since these can work on the smaller partition tables.

    It is highly recommended to test this upgrade on a copy of your production database first.

    This script will guide you through the following steps:

    Step 1: Copy the Sequent 8 database schema and
    migration files to your project's `db/` directory. When this step is completed you
    can customize these files to your liking and commit the changes.

    One decision you need to make is whether you want to define partitions. This is
    mainly useful when your database tables are larger than 10 gigabytes or so. By
    default Sequent 8 uses a single "default" partition.

    The `db/sequent_schema_partitions.sql` file contains the database partitions for
    the `aggregates`, `commands`, and `events` tables, you can customize your
    partitions here.

    Step 2: Shutdown your application and the migration script. The script starts a transaction but DOES NOT
    commit the results.

    Step 3: Check the results and COMMIT or ROLLBACK the result. If you COMMIT,
    you must perform a VACUUM ANALYZE to ensure PostgreSQL can efficiently query
    the new tables

    Step 4: Now you can deploy your Sequent 8 based application and start it again.

  EOS

  step = 0

  if copy_schema
    puts <<~EOS
      #{step += 1}. First a copy of the Sequent 8 database schema and migration scripts are
      added to your db/ directory.

      WARNING: this may overwrite your existing scripts, please use your version control
      system to commit or abort any of the changes!
    EOS
    confirm_or_abort

    FileUtils.copy_entry("#{sequent_gem_dir}/db", 'db')

    puts <<~EOS
      WARNING: The schema files have been copied, please verify and adjust the contents
      before committing and continuing.
    EOS
    confirm_or_abort
  end

  puts "#{step += 1}. Please shut down your existing application."
  confirm_or_abort

  puts <<~EOS
    #{step += 1}. Open a `psql` connection to the database you wish to migrate:

    ```
    psql -U myapp_user myapp_db
    ```
  EOS
  confirm_or_abort

  puts <<~EOS
    #{step += 1}. Run the database migration. If you have a large database this
    can take some time:

    ```
    psql> \\i db/sequent_8_migration.sql
    ```
  EOS
  confirm_or_abort

  puts <<~EOS
    #{step += 1}. After checking everything went OK, COMMIT and optimize the
    database:

    ```
    psql> COMMIT; VACUUM VERBOSE ANALYZE;
    ```
  EOS
  confirm_or_abort

  puts "#{step}. Deploy your Sequent 8 based application and start it."
  confirm_or_abort

  puts 'Congratulations! You are now running your application on Sequent 8!'
end

def args_valid?(*args)
  args.none?(&:empty?)
end

case command
when 'new'
  new_project(*args)
when 'generate', 'g'
  generate(*args)
when 'migrate'
  migrate(*args)
else
  abort("Unknown command #{command}. Try `sequent new myapp`")
end
